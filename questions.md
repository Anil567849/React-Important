Pratical
1. Explain the concept of Higher-Order Components (HOCs) and provide use cases.
2. What is Context API, and how does it help in managing global state?
3. Describe the concept of "lifting state up" in React and provide an example.
4. What is the purpose of the useReducer hook, and how does it compare to useState?
5. Explain the role of keys in React lists and why they are important.
6. What are React Portals, and when should they be used?
7. How do you implement code splitting in a React application? | Describe the use case and implementation of suspense and lazy loading in React.
8. What are custom hooks, and how can they help in reusing logic across components?
9. Explain the concept of uncontrolled components in form handling.
10. How can you use React.memo to optimize component rendering?
11. How do you handle errors in React components, and what are error boundaries?
12. Explain the difference between optimistic and pessimistic updates in React.
13. What is PropTypes, and how does it contribute to type checking in React?
14. How can you implement dark mode in a React application?
15. What are the differences between useRef and createRef?
16. How can you handle data fetching in a React component?
17. How do you manage complex animations in React, and which libraries can be used?


Theory:
1. How does the virtual DOM work in React, and why is it important?
2. What are React Hooks, and how do they differ from class lifecycle methods?
3. How does React's reconciliation algorithm work?
4. How can you optimize the performance of a React application?
5. Describe the benefits and limitations of server-side rendering (SSR) with Next.js.
6. How can you manage side effects in a React application?
7. Discuss the trade-offs between using Redux and the Context API for state management.
8. How does React handle events differently from vanilla JavaScript?
9. What are the common pitfalls of using useEffect, and how can they be avoided?
